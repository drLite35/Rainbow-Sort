// Generated by CoffeeScript 2.7.0
(function() {
  var UPDATE_INTERVAL, bsort, canvas, checkDone, checkDoneInterval, colours, context, defer, height, hsort, initColours, isort, qsort, rectHeight, rectWidth, reset, sort, sort_context, ssort, start, swapRects, timeouts, toHslString, width;

  [rectWidth, rectHeight] = [40, 40];

  UPDATE_INTERVAL = 500;

  // Initialised by reset().
  checkDoneInterval = null;

  colours = null;

  context = null;

  height = null;

  start = null;

  width = null;

  sort_context = null;

  // We set this after document is ready.
  canvas = null;

  timeouts = [];

  defer = function(fn) {
    return timeouts.push(window.setTimeout(fn, 0));
  };

  toHslString = function(h) {
    // Firefox doesn't like a semicolon here. Go figure!
    return `hsl(${h}, 100%, 50%)`;
  };

  initColours = function() {
    var hue, k, ref, ref1, results, val, x, y;
    results = [];
    for (x = k = 0, ref = width, ref1 = rectWidth; ref1 !== 0 && (ref1 > 0 ? k < ref : k > ref); x = k += ref1) {
      results.push((function() {
        var l, ref2, ref3, results1;
        results1 = [];
        for (y = l = 0, ref2 = height, ref3 = rectHeight; ref3 !== 0 && (ref3 > 0 ? l < ref2 : l > ref2); y = l += ref3) {
          val = Math.random();
          hue = Math.floor(256 * val);
          colours.push({
            val: val,
            hue: hue,
            x: x,
            y: y
          });
          context.fillStyle = toHslString(hue);
          results1.push(context.fillRect(x, y, rectWidth, rectHeight));
        }
        return results1;
      })());
    }
    return results;
  };

  checkDone = function() {
    var end, i, k, ms, ref;
    for (i = k = 1, ref = colours.length; (1 <= ref ? k < ref : k > ref); i = 1 <= ref ? ++k : --k) {
      if (colours[i - 1].val > colours[i].val) {
        return;
      }
    }
    end = Date.now();
    window.clearInterval(checkDoneInterval);
    ms = end - start;
    $('#algoName').html($('#algo').val());
    return $('#ms').html(ms);
  };

  reset = function() {
    var timeout, win;
    if (checkDoneInterval != null) {
      window.clearInterval(checkDoneInterval);
    }
    while ((timeout = timeouts.pop())) {
      window.clearTimeout(timeout);
    }
    colours = [];
    win = $(document);
    [width, height] = [$(document).width(), $(document).height()];
    canvas.attr('width', width);
    canvas.attr('height', height);
    context = canvas[0].getContext('2d');
    start = Date.now();
    initColours();
    sort_context = null;
    defer(sort);
    return checkDoneInterval = window.setInterval(checkDone, 10);
  };

  swapRects = function(ind1, ind2) {
    var swap, val1, val2;
    val1 = colours[ind1];
    val2 = colours[ind2];
    swap = function(field) {
      var tmp;
      tmp = val1[field];
      val1[field] = val2[field];
      return val2[field] = tmp;
    };
    swap('val');
    swap('hue');
    context.fillStyle = toHslString(val1.hue);
    context.fillRect(val1.x, val1.y, rectWidth, rectHeight);
    context.fillStyle = toHslString(val2.hue);
    return context.fillRect(val2.x, val2.y, rectWidth, rectHeight);
  };

  isort = function() {
    var count, i, j;
    if (sort_context == null) {
      sort_context = {
        i: 1,
        j: 1,
        count: 0
      };
    }
    ({i, j, count} = sort_context);
    if (colours[j - 1].val > colours[j].val) {
      swapRects(j - 1, j);
    }
    if (j === 1) {
      if (i === colours.length - 1) {
        return;
      }
      sort_context.i++;
      sort_context.j = sort_context.i;
    } else {
      sort_context.j--;
    }
    sort_context.count++;
    if ((sort_context.count % UPDATE_INTERVAL) === 0) {
      return defer(isort);
    } else {
      return isort();
    }
  };

  // Selection sort
  // @author Bernhard Häussner (https://github.com/bxt)
  ssort = function() {
    var count, i, j, min;
    if (sort_context == null) {
      sort_context = {
        i: 1,
        j: 1,
        min: 0,
        count: 0
      };
    }
    ({i, j, count, min} = sort_context);
    if (j === colours.length) {
      swapRects(i - 1, min);
      if (i === colours.length - 1) {
        return;
      }
      sort_context.i++;
      sort_context.min = sort_context.i - 1;
      sort_context.j = sort_context.i;
    } else {
      if (colours[j].val < colours[min].val) {
        sort_context.min = j;
      }
      sort_context.j++;
    }
    sort_context.count++;
    if ((sort_context.count % UPDATE_INTERVAL) === 0) {
      return defer(ssort);
    } else {
      return ssort();
    }
  };

  // Good old bubble sort
  bsort = function() {
    var count, i, swapped;
    if (sort_context == null) {
      sort_context = {
        swapped: false,
        i: 1,
        count: 0
      };
    }
    ({swapped, i, count} = sort_context);
    if (i === colours.length) {
      sort_context.i = 1;
      sort_context.swapped = false;
      if (swapped) {
        bsort();
      }
      return;
    }
    if (colours[i - 1].val > colours[i].val) {
      swapRects(i - 1, i);
      sort_context.swapped = true;
    }
    sort_context.i++;
    sort_context.count++;
    if ((sort_context.count % UPDATE_INTERVAL) === 0) {
      return defer(bsort);
    } else {
      return bsort();
    }
  };

  qsort = function(tukey) {
    var doQsort, getPivotInd, medianOfThree, partition;
    // Put the median of colours.val's in colours[a].
    // Shamelessly stolen from Go's quicksort implementation.
    // See http://golang.org/src/pkg/sort/sort.go
    medianOfThree = function(a, b, c) {
      var m0, m1, m2;
      // Rename vars for clarity, as we want the median in a, not b.
      m0 = b;
      m1 = a;
      m2 = c;
      if (colours[m1].val < colours[m0].val) {
        // Bubble sort on colours[m0,m1,m2].val
        swapRects(m1, m0);
      }
      if (colours[m2].val < colours[m1].val) {
        swapRects(m2, m1);
      }
      if (colours[m1].val < colours[m0].val) {
        return swapRects(m1, m0);
      }
    };
    // Now colours[m0].val <= colours[m1].val <= colours[m2].val
    getPivotInd = function(from, to) {
      var mid, s;
      // Do it this way to avoid overflow.
      mid = Math.floor(from + (to - from) / 2);
      if (!tukey) {
        return mid;
      }
      // Using Tukey's 'median of medians'
      // See http://www.johndcook.com/blog/2009/06/23/tukey-median-ninther/
      if (to - from > 40) {
        s = Math.floor((to - from) / 8);
        medianOfThree(from, from + s, from + 2 * s);
        medianOfThree(mid, mid - s, mid + s);
        medianOfThree(to - 1, to - 1 - s, to - 1 - 2 * s);
      }
      medianOfThree(from, mid, to - 1);
      // We've put the median in from.
      return from;
    };
    partition = function(from, to, pivotInd) {
      var i, k, pivot, ref, ref1;
      pivot = colours[pivotInd].val;
      // Put pivot at end for now.
      swapRects(pivotInd, to);
      pivotInd = from;
      for (i = k = ref = from, ref1 = to; (ref <= ref1 ? k < ref1 : k > ref1); i = ref <= ref1 ? ++k : --k) {
        if (colours[i].val <= pivot) {
          swapRects(i, pivotInd);
          pivotInd++;
        }
      }
      // Swap 'em back.
      swapRects(pivotInd, to);
      return pivotInd;
    };
    doQsort = function(from, to) {
      var pivotInd;
      if (from >= to) {
        return;
      }
      pivotInd = getPivotInd(from, to);
      pivotInd = partition(from, to, pivotInd);
      return defer(function() {
        doQsort(from, pivotInd - 1);
        return doQsort(pivotInd + 1, to);
      });
    };
    return doQsort(0, colours.length - 1);
  };

  // Heapsort
  // Based on this Java implementation: http://git.io/heapsort
  // @author Bernhard Häussner (https://github.com/bxt)
  hsort = function() {
    var i, k, l, maxHeapify, popMaxValue, ref, ref1, size, stack, work;
    // Let the browser render between steps using a call stack
    stack = [];
    work = function() {
      if (stack.length) {
        stack.pop()(); // execute stack top
        return defer(work); // loop
      }
    };
    size = colours.length;
    // Make branch from i downwards a proper max heap
    maxHeapify = function(i) {
      var largest, left, right;
      left = i * 2 + 1;
      right = i * 2 + 2;
      largest = i;
      if (left < size && colours[left].val > colours[i].val) {
        largest = left;
      }
      if (right < size && colours[right].val > colours[largest].val) {
        largest = right;
      }
      if (i !== largest) {
        swapRects(i, largest);
        return maxHeapify(largest);
      }
    };
    //stack.push(-> maxHeapify(largest))

    // Remove the top of the heap and move it behind the heap
    popMaxValue = function() {
      size--;
      swapRects(0, size);
      if (size > 0) {
        return maxHeapify(0);
      }
    };
// Fill the call stack (reverse order)
    for (i = k = ref = size - 1; (ref <= 0 ? k < 0 : k > 0); i = ref <= 0 ? ++k : --k) {
      stack.push(popMaxValue);
    }
    for (i = l = 0, ref1 = Math.floor(size / 2) - 1; (0 <= ref1 ? l <= ref1 : l >= ref1); i = 0 <= ref1 ? ++l : --l) {
      (function(i) {
        return stack.push(function() {
          return maxHeapify(i);
        });
      })(i);
    }
    return work();
  };

  // Default to bubble sort.
  sort = bsort;

  $(document).ready(function() {
    canvas = $('#mainCanvas');
    $('#squareSize').val(rectWidth);
    window.onresize = function() {
      return reset();
    };
    $('#algo').change(function() {
      var selected;
      selected = $('#algo').val();
      sort = (function() {
        switch ($(this).children(':selected').attr('id')) {
          case 'bsort':
            return bsort;
          case 'isort':
            return isort;
          case 'qsort1':
            return function() {
              return qsort(false);
            };
          case 'qsort2':
            return function() {
              return qsort(true);
            };
          case 'hsort':
            return hsort;
          case 'ssort':
            return ssort;
        }
      }).call(this);
      return reset();
    });
    $('#squareSize').change(function() {
      var n;
      n = parseInt($('#squareSize').val(), 10);
      if (isNaN(n)) {
        return;
      }
      rectWidth = rectHeight = n;
      return reset();
    });
    $('#reset').click(function() {
      return reset();
    });
    return reset();
  });

}).call(this);
